opt_out_usage

default_platform(:ios)

# Configure AWS SDK for MinIO (path-style addressing required)
def configure_minio
  if ENV['AWS_ENDPOINT_URL']
    require 'aws-sdk-s3'
    Aws.config.update(
      endpoint: ENV['AWS_ENDPOINT_URL'],
      force_path_style: true,
      region: 'us-east-1'
    )
    UI.message("Configured AWS SDK for MinIO: #{ENV['AWS_ENDPOINT_URL']}")
  end
end

ROOT_DIR = File.expand_path("..", __dir__)
XCODEPROJ = "#{ROOT_DIR}/src-tauri/gen/apple/lunch.xcodeproj"
APP_IDENTIFIER = "com.lunch.desktop"
TEAM_ID = "654C9Y2C3F"
OUTPUT_DIR = "#{ROOT_DIR}/src-tauri/gen/apple/build"
IPA_PATH = "#{OUTPUT_DIR}/Lunch.ipa"

# Fix Tauri iOS project issue where Externals folder in sources causes
# "Multiple commands produce libapp.a" error (both debug and release copied)
# See: https://github.com/tauri-apps/tauri/issues/13578
# Also ensures ASSETCATALOG_COMPILER_APPICON_NAME is set so icons appear in builds
def fix_tauri_project_yml
  project_yml_path = "#{ROOT_DIR}/src-tauri/gen/apple/project.yml"
  return unless File.exist?(project_yml_path)

  content = File.read(project_yml_path)
  modified = false

  # Remove "- path: Externals" from sources to prevent duplicate libapp.a
  # libapp.a is already linked via dependencies, no need to copy as resource
  if content.include?("- path: Externals")
    content.gsub!(/^\s*- path: Externals\n/, "")
    UI.message("Fixed project.yml: removed Externals from sources")
    modified = true
  end

  # Add ASSETCATALOG_COMPILER_APPICON_NAME setting to ensure icons are included
  # This setting gets lost when xcodegen regenerates the project
  unless content.include?("ASSETCATALOG_COMPILER_APPICON_NAME")
    # Find the base: section under settings: and add the icon setting
    content.gsub!(/(settings:\s+base:\s+.*?VALID_ARCHS:.*?\n)/m) do |match|
      "#{match}        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon\n"
    end
    UI.message("Fixed project.yml: added ASSETCATALOG_COMPILER_APPICON_NAME setting")
    modified = true
  end

  if modified
    File.write(project_yml_path, content)
    # Regenerate Xcode project with xcodegen
    sh("cd #{ROOT_DIR}/src-tauri/gen/apple && xcodegen generate")
  end
end

# App Store Connect API Key configuration
# Set these environment variables:
# - APP_STORE_CONNECT_API_KEY_KEY_ID: API Key ID
# - APP_STORE_CONNECT_API_KEY_ISSUER_ID: Issuer ID
# - APP_STORE_CONNECT_API_KEY_KEY: Base64-encoded .p8 key content (or path to .p8 file)
def api_key
  if ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'] && ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_KEY'],
      is_key_content_base64: true,
      in_house: false
    )
  else
    nil
  end
end

CI_KEYCHAIN_NAME = "fastlane_ci"
CI_KEYCHAIN_PASSWORD = "fastlane_ci_password"
IOS_INFO_PLIST = "#{ROOT_DIR}/src-tauri/gen/apple/lunch_iOS/Info.plist"

# Get the app version from Cargo.toml
def get_app_version
  cargo_toml = File.read("#{ROOT_DIR}/src-tauri/Cargo.toml")
  if cargo_toml =~ /^version\s*=\s*"([^"]+)"/
    $1
  else
    "1.0.0"
  end
end

# Get a unique build number using timestamp
# This avoids race conditions with TestFlight API returning stale data
def get_next_build_number
  # Use seconds since Jan 1, 2024 00:00:00 UTC
  # Max Android versionCode is 2,100,000,000
  # This gives us ~66 years of headroom (2024-2090)
  epoch = Time.utc(2024, 1, 1, 0, 0, 0)
  build_number = (Time.now.utc - epoch).to_i
  UI.message("Build number (seconds since 2024): #{build_number}")
  build_number
end

# Update tauri.conf.json with version from Cargo.toml and unique build number
def update_tauri_config_version
  app_version = get_app_version
  build_number = get_next_build_number

  tauri_conf_path = "#{ROOT_DIR}/src-tauri/tauri.conf.json"
  tauri_conf = JSON.parse(File.read(tauri_conf_path))

  # Set app version (CFBundleShortVersionString)
  tauri_conf["version"] = app_version

  # Set iOS-specific bundle version (CFBundleVersion) for unique build numbers
  tauri_conf["bundle"] ||= {}
  tauri_conf["bundle"]["iOS"] ||= {}
  tauri_conf["bundle"]["iOS"]["bundleVersion"] = build_number.to_s

  File.write(tauri_conf_path, JSON.pretty_generate(tauri_conf))
  UI.success("Updated tauri.conf.json: v#{app_version} (build #{build_number})")

  { version: app_version, build: build_number }
end

# Setup temporary keychain for CI environments
# Only runs on GitHub Actions (not local CI) to avoid GUI prompts on dev machines
def setup_ci_keychain
  return unless ENV['CI'] && ENV['GITHUB_ACTIONS']

  create_keychain(
    name: CI_KEYCHAIN_NAME,
    password: CI_KEYCHAIN_PASSWORD,
    default_keychain: false,  # don't replace user's default keychain
    unlock: true,
    timeout: 3600,
    lock_when_sleeps: false,
    add_to_search_list: true
  )
end

# Set partition list after match imports keys so codesign can access without GUI prompt
def set_keychain_partition_list
  return unless ENV['CI'] && ENV['GITHUB_ACTIONS']

  keychain_path = File.expand_path("~/Library/Keychains/#{CI_KEYCHAIN_NAME}-db")
  return unless File.exist?(keychain_path)

  sh("security set-key-partition-list -S apple-tool:,apple: -s -k #{CI_KEYCHAIN_PASSWORD.shellescape} #{keychain_path.shellescape}", log: false)
end

# Cleanup CI keychain
def cleanup_ci_keychain
  return unless ENV['CI'] && ENV['GITHUB_ACTIONS']

  keychain_path = File.expand_path("~/Library/Keychains/#{CI_KEYCHAIN_NAME}-db")
  delete_keychain(name: CI_KEYCHAIN_NAME) if File.exist?(keychain_path)
end

platform :ios do
  # Cleanup CI keychain after successful lane completion
  after_all do |lane|
    cleanup_ci_keychain
  end

  # Cleanup CI keychain on error to prevent stale keychains
  error do |lane, exception|
    cleanup_ci_keychain
  end

  desc "Sync code signing certificates"
  lane :certificates do
    configure_minio
    setup_ci_keychain
    match(
      type: "appstore",
      readonly: true,
      keychain_name: ENV['CI'] ? CI_KEYCHAIN_NAME : nil,
      keychain_password: ENV['CI'] ? CI_KEYCHAIN_PASSWORD : nil
    )
    set_keychain_partition_list
  end

  desc "Build only (no upload) - for testing"
  lane :build_only do
    configure_minio
    match(type: "appstore", readonly: true)

    # Fix Tauri project.yml to prevent duplicate libapp.a error
    fix_tauri_project_yml

    # Configure Xcode project signing before Tauri build
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ,
      team_id: TEAM_ID,
      bundle_identifier: APP_IDENTIFIER,
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    # TODO: move to separate xml file
    # Write custom ExportOptions.plist for app-store export
    export_options_path = "#{ROOT_DIR}/src-tauri/gen/apple/ExportOptions.plist"
    File.write(export_options_path, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>#{TEAM_ID}</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
              <key>#{APP_IDENTIFIER}</key>
              <string>match AppStore #{APP_IDENTIFIER}</string>
          </dict>
          <key>uploadSymbols</key>
          <false/>
      </dict>
      </plist>
    PLIST

    # Build using Tauri
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios build --export-method app-store-connect")

    # Find the built IPA
    tauri_ipa = "#{ROOT_DIR}/src-tauri/gen/apple/build/arm64/Lunch.ipa"
    FileUtils.mkdir_p(OUTPUT_DIR)
    FileUtils.cp(tauri_ipa, IPA_PATH) if File.exist?(tauri_ipa)

    UI.success("Build complete! IPA at: #{IPA_PATH}")
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    configure_minio
    setup_ci_keychain
    match(
      type: "appstore",
      readonly: true,
      keychain_name: ENV['CI'] ? CI_KEYCHAIN_NAME : nil,
      keychain_password: ENV['CI'] ? CI_KEYCHAIN_PASSWORD : nil
    )
    set_keychain_partition_list

    # Update tauri.conf.json with version and unique build number BEFORE init
    # This ensures Tauri uses the correct version when generating the iOS project
    update_tauri_config_version

    # Initialize iOS project if needed (creates Info.plist with correct version)
    unless File.exist?(XCODEPROJ)
      UI.message("Initializing iOS project...")
      sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios init")
    end

    # Fix Tauri project.yml to prevent duplicate libapp.a error
    fix_tauri_project_yml

    # Set encryption exemption for App Store compliance
    set_info_plist_value(
      path: IOS_INFO_PLIST,
      key: "ITSAppUsesNonExemptEncryption",
      value: false
    )

    # Configure Xcode project signing before Tauri build
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ,
      team_id: TEAM_ID,
      bundle_identifier: APP_IDENTIFIER,
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    # Write custom ExportOptions.plist for app-store export
    export_options_path = "#{ROOT_DIR}/src-tauri/gen/apple/ExportOptions.plist"
    File.write(export_options_path, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>#{TEAM_ID}</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
              <key>#{APP_IDENTIFIER}</key>
              <string>match AppStore #{APP_IDENTIFIER}</string>
          </dict>
          <key>uploadSymbols</key>
          <false/>
      </dict>
      </plist>
    PLIST

    # Build using Tauri (will use our custom ExportOptions.plist)
    # Use app-store-connect flag so Tauri doesn't overwrite our plist
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios build --export-method app-store-connect")

    # Find the built IPA (Tauri outputs to arm64 subdirectory)
    tauri_ipa = "#{ROOT_DIR}/src-tauri/gen/apple/build/arm64/Lunch.ipa"

    # Copy to expected location
    FileUtils.mkdir_p(OUTPUT_DIR)
    FileUtils.cp(tauri_ipa, IPA_PATH) if File.exist?(tauri_ipa)

    # Upload to TestFlight
    upload_to_testflight(
      ipa: IPA_PATH,
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      uses_non_exempt_encryption: false
    )
  end

  desc "Upload to App Store"
  lane :release do
    configure_minio
    setup_ci_keychain
    match(
      type: "appstore",
      readonly: true,
      keychain_name: ENV['CI'] ? CI_KEYCHAIN_NAME : nil,
      keychain_password: ENV['CI'] ? CI_KEYCHAIN_PASSWORD : nil
    )
    set_keychain_partition_list

    # Update tauri.conf.json with version and unique build number BEFORE init
    # This ensures Tauri uses the correct version when generating the iOS project
    update_tauri_config_version

    # Initialize iOS project if needed (creates Info.plist with correct version)
    unless File.exist?(XCODEPROJ)
      UI.message("Initializing iOS project...")
      sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios init")
    end

    # Fix Tauri project.yml to prevent duplicate libapp.a error
    fix_tauri_project_yml

    # Set encryption exemption for App Store compliance
    set_info_plist_value(
      path: IOS_INFO_PLIST,
      key: "ITSAppUsesNonExemptEncryption",
      value: false
    )

    # Configure Xcode project signing before Tauri build
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ,
      team_id: TEAM_ID,
      bundle_identifier: APP_IDENTIFIER,
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    # Write custom ExportOptions.plist for app-store export
    export_options_path = "#{ROOT_DIR}/src-tauri/gen/apple/ExportOptions.plist"
    File.write(export_options_path, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>#{TEAM_ID}</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
              <key>#{APP_IDENTIFIER}</key>
              <string>match AppStore #{APP_IDENTIFIER}</string>
          </dict>
          <key>uploadSymbols</key>
          <false/>
      </dict>
      </plist>
    PLIST

    # Build using Tauri
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios build --export-method app-store-connect")

    # Find the built IPA
    tauri_ipa = "#{ROOT_DIR}/src-tauri/gen/apple/build/arm64/Lunch.ipa"

    # Copy to expected location
    FileUtils.mkdir_p(OUTPUT_DIR)
    FileUtils.cp(tauri_ipa, IPA_PATH) if File.exist?(tauri_ipa)

    upload_to_app_store(
      ipa: IPA_PATH,
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true
    )
  end
end

platform :android do
  desc "Build Android release (AAB and APK)"
  lane :build do
    # Set ANDROID_HOME for this session
    ENV['ANDROID_HOME'] = "/opt/homebrew/share/android-commandlinetools"
    ENV['ANDROID_NDK_HOME'] = "#{ENV['ANDROID_HOME']}/ndk/28.2.13676358"

    # Update tauri.conf.json with version from Cargo.toml
    app_version = get_app_version
    build_number = get_next_build_number

    tauri_conf_path = "#{ROOT_DIR}/src-tauri/tauri.conf.json"
    tauri_conf = JSON.parse(File.read(tauri_conf_path))
    tauri_conf["version"] = app_version
    tauri_conf["bundle"] ||= {}
    tauri_conf["bundle"]["android"] ||= {}
    tauri_conf["bundle"]["android"]["versionCode"] = build_number
    File.write(tauri_conf_path, JSON.pretty_generate(tauri_conf))

    UI.success("Updated tauri.conf.json: v#{app_version} (build #{build_number})")

    # Build Android app using Tauri
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri android build")

    UI.success("Android build complete!")
  end

  desc "Build and upload to Google Play Store beta track"
  lane :beta do
    # Set ANDROID_HOME for this session
    ENV['ANDROID_HOME'] = "/opt/homebrew/share/android-commandlinetools"
    ENV['ANDROID_NDK_HOME'] = "#{ENV['ANDROID_HOME']}/ndk/28.2.13676358"

    # Update tauri.conf.json with version from Cargo.toml
    app_version = get_app_version
    build_number = get_next_build_number

    tauri_conf_path = "#{ROOT_DIR}/src-tauri/tauri.conf.json"
    tauri_conf = JSON.parse(File.read(tauri_conf_path))
    tauri_conf["version"] = app_version
    tauri_conf["bundle"] ||= {}
    tauri_conf["bundle"]["android"] ||= {}
    tauri_conf["bundle"]["android"]["versionCode"] = build_number
    File.write(tauri_conf_path, JSON.pretty_generate(tauri_conf))

    UI.success("Updated tauri.conf.json: v#{app_version} (build #{build_number})")

    # Build Android app bundle using Tauri CLI
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri android build --aab true")

    # Upload to Play Store beta track
    upload_to_play_store(
      package_name: "com.lunch.app",
      track: "beta",
      aab: "#{ROOT_DIR}/src-tauri/gen/android/app/build/outputs/bundle/universalRelease/app-universal-release.aab",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Uploaded to Google Play Store beta track!")
  end

  desc "Build and upload to Google Play Store internal testing track"
  lane :internal do
    # Set ANDROID_HOME for this session
    ENV['ANDROID_HOME'] = "/opt/homebrew/share/android-commandlinetools"
    ENV['ANDROID_NDK_HOME'] = "#{ENV['ANDROID_HOME']}/ndk/28.2.13676358"

    # Update tauri.conf.json with version from Cargo.toml
    app_version = get_app_version
    build_number = get_next_build_number

    tauri_conf_path = "#{ROOT_DIR}/src-tauri/tauri.conf.json"
    tauri_conf = JSON.parse(File.read(tauri_conf_path))
    tauri_conf["version"] = app_version
    tauri_conf["bundle"] ||= {}
    tauri_conf["bundle"]["android"] ||= {}
    tauri_conf["bundle"]["android"]["versionCode"] = build_number
    File.write(tauri_conf_path, JSON.pretty_generate(tauri_conf))

    UI.success("Updated tauri.conf.json: v#{app_version} (build #{build_number})")

    # Build Android app bundle using Tauri CLI
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri android build --aab true")

    # Upload to Play Store internal testing track
    upload_to_play_store(
      package_name: "com.lunch.app",
      track: "internal",
      aab: "#{ROOT_DIR}/src-tauri/gen/android/app/build/outputs/bundle/universalRelease/app-universal-release.aab",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Uploaded to Google Play Store internal testing track!")
  end

  desc "Upload to Google Play Store production"
  lane :release do
    # Set ANDROID_HOME for this session
    ENV['ANDROID_HOME'] = "/opt/homebrew/share/android-commandlinetools"
    ENV['ANDROID_NDK_HOME'] = "#{ENV['ANDROID_HOME']}/ndk/28.2.13676358"

    # Update tauri.conf.json with version from Cargo.toml
    app_version = get_app_version
    build_number = get_next_build_number

    tauri_conf_path = "#{ROOT_DIR}/src-tauri/tauri.conf.json"
    tauri_conf = JSON.parse(File.read(tauri_conf_path))
    tauri_conf["version"] = app_version
    tauri_conf["bundle"] ||= {}
    tauri_conf["bundle"]["android"] ||= {}
    tauri_conf["bundle"]["android"]["versionCode"] = build_number
    File.write(tauri_conf_path, JSON.pretty_generate(tauri_conf))

    UI.success("Updated tauri.conf.json: v#{app_version} (build #{build_number})")

    # Build Android app bundle using Tauri CLI
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri android build --aab true")

    # Upload to Play Store production track
    upload_to_play_store(
      package_name: "com.lunch.app",
      track: "production",
      aab: "#{ROOT_DIR}/src-tauri/gen/android/app/build/outputs/bundle/universalRelease/app-universal-release.aab",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )

    UI.success("Uploaded to Google Play Store production track!")
  end
end
