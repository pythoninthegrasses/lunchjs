opt_out_usage

default_platform(:ios)

# Configure AWS SDK for MinIO (path-style addressing required)
def configure_minio
  if ENV['AWS_ENDPOINT_URL']
    require 'aws-sdk-s3'
    Aws.config.update(
      endpoint: ENV['AWS_ENDPOINT_URL'],
      force_path_style: true,
      region: 'us-east-1'
    )
    UI.message("Configured AWS SDK for MinIO: #{ENV['AWS_ENDPOINT_URL']}")
  end
end

ROOT_DIR = File.expand_path("..", __dir__)
XCODEPROJ = "#{ROOT_DIR}/src-tauri/gen/apple/lunch.xcodeproj"
APP_IDENTIFIER = "com.lunch.desktop"
TEAM_ID = "654C9Y2C3F"
OUTPUT_DIR = "#{ROOT_DIR}/src-tauri/gen/apple/build"
IPA_PATH = "#{OUTPUT_DIR}/Lunch.ipa"

# Fix Tauri iOS project issue where Externals folder in sources causes
# "Multiple commands produce libapp.a" error (both debug and release copied)
# See: https://github.com/tauri-apps/tauri/issues/13578
def fix_tauri_project_yml
  project_yml_path = "#{ROOT_DIR}/src-tauri/gen/apple/project.yml"
  return unless File.exist?(project_yml_path)

  content = File.read(project_yml_path)
  # Remove "- path: Externals" from sources to prevent duplicate libapp.a
  # libapp.a is already linked via dependencies, no need to copy as resource
  if content.include?("- path: Externals")
    content.gsub!(/^\s*- path: Externals\n/, "")
    File.write(project_yml_path, content)
    UI.message("Fixed project.yml: removed Externals from sources")
    # Regenerate Xcode project with xcodegen
    sh("cd #{ROOT_DIR}/src-tauri/gen/apple && xcodegen generate")
  end
end

# App Store Connect API Key configuration
# Set these environment variables:
# - APP_STORE_CONNECT_API_KEY_KEY_ID: API Key ID
# - APP_STORE_CONNECT_API_KEY_ISSUER_ID: Issuer ID
# - APP_STORE_CONNECT_API_KEY_KEY: Base64-encoded .p8 key content (or path to .p8 file)
def api_key
  if ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'] && ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_KEY'],
      is_key_content_base64: true,
      in_house: false
    )
  else
    nil
  end
end

CI_KEYCHAIN_NAME = "fastlane_ci"
CI_KEYCHAIN_PASSWORD = "fastlane_ci_password"
IOS_INFO_PLIST = "#{ROOT_DIR}/src-tauri/gen/apple/lunch_iOS/Info.plist"

# Get the app version from Cargo.toml
def get_app_version
  cargo_toml = File.read("#{ROOT_DIR}/src-tauri/Cargo.toml")
  if cargo_toml =~ /^version\s*=\s*"([^"]+)"/
    $1
  else
    "1.0.0"
  end
end

# Get a unique build number using timestamp
# This avoids race conditions with TestFlight API returning stale data
def get_next_build_number
  # Format: YYMMDDHHMM (fits in 32-bit integer, always increasing)
  build_number = Time.now.utc.strftime("%y%m%d%H%M").to_i
  UI.message("Build number (timestamp): #{build_number}")
  build_number
end

# Update tauri.conf.json with version from Cargo.toml and unique build number
def update_tauri_config_version
  app_version = get_app_version
  build_number = get_next_build_number

  tauri_conf_path = "#{ROOT_DIR}/src-tauri/tauri.conf.json"
  tauri_conf = JSON.parse(File.read(tauri_conf_path))

  # Set app version (CFBundleShortVersionString)
  tauri_conf["version"] = app_version

  # Set iOS-specific bundle version (CFBundleVersion) for unique build numbers
  tauri_conf["bundle"] ||= {}
  tauri_conf["bundle"]["iOS"] ||= {}
  tauri_conf["bundle"]["iOS"]["bundleVersion"] = build_number.to_s

  File.write(tauri_conf_path, JSON.pretty_generate(tauri_conf))
  UI.success("Updated tauri.conf.json: v#{app_version} (build #{build_number})")

  { version: app_version, build: build_number }
end

# Setup temporary keychain for CI environments
def setup_ci_keychain
  if ENV['CI']
    create_keychain(
      name: CI_KEYCHAIN_NAME,
      password: CI_KEYCHAIN_PASSWORD,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false,
      add_to_search_list: true
    )
  end
end

# Cleanup CI keychain
def cleanup_ci_keychain
  if ENV['CI']
    delete_keychain(name: CI_KEYCHAIN_NAME) if File.exist?(File.expand_path("~/Library/Keychains/#{CI_KEYCHAIN_NAME}-db"))
  end
end

platform :ios do
  desc "Sync code signing certificates"
  lane :certificates do
    configure_minio
    setup_ci_keychain
    match(
      type: "appstore",
      readonly: true,
      keychain_name: ENV['CI'] ? CI_KEYCHAIN_NAME : nil,
      keychain_password: ENV['CI'] ? CI_KEYCHAIN_PASSWORD : nil
    )
  end

  desc "Build only (no upload) - for testing"
  lane :build_only do
    configure_minio
    match(type: "appstore", readonly: true)

    # Fix Tauri project.yml to prevent duplicate libapp.a error
    fix_tauri_project_yml

    # Configure Xcode project signing before Tauri build
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ,
      team_id: TEAM_ID,
      bundle_identifier: APP_IDENTIFIER,
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    # TODO: move to separate xml file
    # Write custom ExportOptions.plist for app-store export
    export_options_path = "#{ROOT_DIR}/src-tauri/gen/apple/ExportOptions.plist"
    File.write(export_options_path, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>#{TEAM_ID}</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
              <key>#{APP_IDENTIFIER}</key>
              <string>match AppStore #{APP_IDENTIFIER}</string>
          </dict>
          <key>uploadSymbols</key>
          <false/>
      </dict>
      </plist>
    PLIST

    # Build using Tauri
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios build --export-method app-store-connect")

    # Find the built IPA
    tauri_ipa = "#{ROOT_DIR}/src-tauri/gen/apple/build/arm64/Lunch.ipa"
    FileUtils.mkdir_p(OUTPUT_DIR)
    FileUtils.cp(tauri_ipa, IPA_PATH) if File.exist?(tauri_ipa)

    UI.success("Build complete! IPA at: #{IPA_PATH}")
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    configure_minio
    setup_ci_keychain
    match(
      type: "appstore",
      readonly: true,
      keychain_name: ENV['CI'] ? CI_KEYCHAIN_NAME : nil,
      keychain_password: ENV['CI'] ? CI_KEYCHAIN_PASSWORD : nil
    )

    # Update tauri.conf.json with version and unique build number BEFORE init
    # This ensures Tauri uses the correct version when generating the iOS project
    update_tauri_config_version

    # Initialize iOS project if needed (creates Info.plist with correct version)
    unless File.exist?(XCODEPROJ)
      UI.message("Initializing iOS project...")
      sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios init")
    end

    # Fix Tauri project.yml to prevent duplicate libapp.a error
    fix_tauri_project_yml

    # Configure Xcode project signing before Tauri build
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ,
      team_id: TEAM_ID,
      bundle_identifier: APP_IDENTIFIER,
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    # Write custom ExportOptions.plist for app-store export
    export_options_path = "#{ROOT_DIR}/src-tauri/gen/apple/ExportOptions.plist"
    File.write(export_options_path, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>#{TEAM_ID}</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
              <key>#{APP_IDENTIFIER}</key>
              <string>match AppStore #{APP_IDENTIFIER}</string>
          </dict>
          <key>uploadSymbols</key>
          <false/>
      </dict>
      </plist>
    PLIST

    # Build using Tauri (will use our custom ExportOptions.plist)
    # Use app-store-connect flag so Tauri doesn't overwrite our plist
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios build --export-method app-store-connect")

    # Find the built IPA (Tauri outputs to arm64 subdirectory)
    tauri_ipa = "#{ROOT_DIR}/src-tauri/gen/apple/build/arm64/Lunch.ipa"

    # Copy to expected location
    FileUtils.mkdir_p(OUTPUT_DIR)
    FileUtils.cp(tauri_ipa, IPA_PATH) if File.exist?(tauri_ipa)

    # Upload to TestFlight
    upload_to_testflight(
      ipa: IPA_PATH,
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      uses_non_exempt_encryption: false
    )
  end

  desc "Upload to App Store"
  lane :release do
    configure_minio
    setup_ci_keychain
    match(
      type: "appstore",
      readonly: true,
      keychain_name: ENV['CI'] ? CI_KEYCHAIN_NAME : nil,
      keychain_password: ENV['CI'] ? CI_KEYCHAIN_PASSWORD : nil
    )

    # Update tauri.conf.json with version and unique build number BEFORE init
    update_tauri_config_version

    # Initialize iOS project if needed (creates Info.plist with correct version)
    unless File.exist?(XCODEPROJ)
      UI.message("Initializing iOS project...")
      sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios init")
    end

    # Fix Tauri project.yml to prevent duplicate libapp.a error
    fix_tauri_project_yml

    # Configure Xcode project signing before Tauri build
    update_code_signing_settings(
      use_automatic_signing: false,
      path: XCODEPROJ,
      team_id: TEAM_ID,
      bundle_identifier: APP_IDENTIFIER,
      profile_name: "match AppStore #{APP_IDENTIFIER}",
      code_sign_identity: "Apple Distribution"
    )

    # Write custom ExportOptions.plist for app-store export
    export_options_path = "#{ROOT_DIR}/src-tauri/gen/apple/ExportOptions.plist"
    File.write(export_options_path, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>#{TEAM_ID}</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
              <key>#{APP_IDENTIFIER}</key>
              <string>match AppStore #{APP_IDENTIFIER}</string>
          </dict>
          <key>uploadSymbols</key>
          <false/>
      </dict>
      </plist>
    PLIST

    # Build using Tauri
    sh("cd #{ROOT_DIR}/src-tauri && npx tauri ios build --export-method app-store-connect")

    # Find the built IPA
    tauri_ipa = "#{ROOT_DIR}/src-tauri/gen/apple/build/arm64/Lunch.ipa"

    # Copy to expected location
    FileUtils.mkdir_p(OUTPUT_DIR)
    FileUtils.cp(tauri_ipa, IPA_PATH) if File.exist?(tauri_ipa)

    upload_to_app_store(
      ipa: IPA_PATH,
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true
    )
  end
end
